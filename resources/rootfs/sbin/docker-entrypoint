#!/usr/bin/php -f
<?php
/*
 * MikoPBX - free phone system for small business
 * Copyright © 2017-2021 Alexey Portnov and Nikolay Beketov
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program.
 * If not, see <https://www.gnu.org/licenses/>.
 */

require_once('Globals.php');
use MikoPBX\Core\System\Processes;
use MikoPBX\Core\System\Util;
use function MikoPBX\Common\Config\appPath;

class Entrypoint
{
    private array  $env;
    private array  $incSettings;
    private array  $settings;
    private string $pathInc;
    public  float  $workerStartTime;
    public  const  PATH_DB = '/cf/conf/mikopbx.db';

    public function __construct()
    {
        pcntl_async_signals(true);
        pcntl_signal(SIGTERM, [$this, 'signalHandler']);
        register_shutdown_function([$this, 'shutdownHandler']);

        $this->env = [
            'BEANSTALK_PORT'  => 'beanstalk',
            'REDIS_PORT'      => 'redis',
            'GNATS_PORT'      => 'gnats',
            // General Settings.
            'SSH_PORT'        => 'SSHPort',
            'WEB_PORT'        => 'WEBPort',
            'WEB_HTTPS_PORT'  => 'WEBHTTPSPort',
            'SIP_PORT'        => 'SIPPort',
            'RTP_FROM'        => 'RTPPortFrom',
            'RTP_TO'          => 'RTPPortTo',
            'IAX_PORT'        => 'IAXPort',
            'AMI_PORT'        => 'AMIPort',
            'AJAM_PORT'       => 'AJAMPort',
            'AJAM_PORT_TLS'   => 'AJAMPortTLS',
        ];
    }

    /**
     * Process async system signal
     *
     * @param int $signal
     */
    public function signalHandler(int $signal): void
    {
        Util::sysLogMsg(static::class, "Receive signal to restart  " . $signal, LOG_DEBUG);
        $freeStorage = Util::which('freestorage');
        $freeOffload = Util::which('freeupoffload');

        $commands = 'exec </dev/console >/dev/console 2>/dev/console; '.
                    "$freeStorage; ".
                    "$freeOffload;";
        Processes::mwExec($commands);
    }

    /**
     * Process shutdown event
     *
     */
    public function shutdownHandler(): void
    {
        $e = error_get_last();
        $delta = round(microtime(true) - $this->workerStartTime,2);
        if ($e === null) {
            Util::sysLogMsg(static::class, "shutdownHandler after $delta seconds", LOG_DEBUG);
        } else {
            $details = (string) print_r($e, true);
            Util::sysLogMsg(static::class, "shutdownHandler after $delta seconds with error: $details", LOG_DEBUG);
        }
    }

    public function start():void
    {
        $this->workerStartTime = microtime(true);

        $sysLogdPath = Util::which('syslogd');
        // Запуск системного лога.
        Processes::mwExecBg($sysLogdPath.' -S -C512');

        $out = [];
        Processes::mwExec('sqlite3 /cf/conf/mikopbx.db .tables', $out);
        if(trim(implode('',$out)) === ''){
            Util::mwMkdir(dirname(self::PATH_DB));
            Processes::mwExec("rm -rf ".self::PATH_DB."; cp /conf.default/mikopbx.db ".self::PATH_DB);
        }

        $this->checkUpdate();
        $commands = 'exec </dev/console >/dev/console 2>/dev/console;'.
            '/etc/rc/bootup 2>/dev/null &&'.
            '/etc/rc/bootup_pbx 2>/dev/null';
        passthru($commands);
        while (true){
            sleep(2);
        }
    }

    /**
     * Инициализация настроек. Необходима для проверки и обновления настроек портов.
     */
    private function initSettings():void{
        $this->pathInc  = appPath('config/mikopbx-settings.json');
        $jsonString     = file_get_contents($this->pathInc);
        try {
            $this->incSettings = json_decode($jsonString, true, 512, JSON_THROW_ON_ERROR);
        } catch (JsonException $exception) {
            $this->incSettings = [];
            throw new Error("$this->pathInc has broken format");
        }

        $out = [];
        Processes::mwExec("sqlite3 ".self::PATH_DB." 'SELECT * FROM m_PbxSettings' | grep -i port", $out);
        $this->settings = [];
        $keys = array_flip($this->env);
        foreach ($out as $row){
            $data = explode('|', $row);
            $key  = $data[0]??'';
            $value= $data[1]??'';

            if(!isset($keys[$key]) || empty($value)){
                continue;
            }
            $this->settings[$key] = $value;
        }
    }

    /**
     * Проверяем есть ли указание применить кастомное значение порта.
     * Вызывеем функцию обновления сохраненной настройки.
     */
    public function checkUpdate():void
    {
        $this->initSettings();
        foreach ($this->env as $key => $dataPath) {
            $newValue = getenv($key);
            if(!is_numeric($newValue)){
                continue;
            }
            $isInc = false;
            $oldValue    = $this->settings[$dataPath]??'';
            if(empty($oldValue)){
                $oldValue = $this->incSettings[$dataPath]['port']??'';
                $isInc = true;
            }

            if (empty($oldValue) || $newValue === $oldValue){
                continue;
            }
            $this->updateSetting($dataPath, $newValue, $isInc);
        }
    }

    private function updateSetting($dataPath, $newValue, $isInc):void
    {
        $msg = " - Update $dataPath (port) to '$newValue' ...";
        Util::echoWithSyslog($msg);
        if($isInc === true){
            $this->incSettings[$dataPath]['port'] = $newValue;
            $res = file_put_contents($this->pathInc, json_encode($this->incSettings, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES));
            $result = (false !== $res);
        }else{
            $res = Processes::mwExec("sqlite3 ".self::PATH_DB." 'UPDATE m_PbxSettings SET value=\"$newValue\" WHERE key=\"$dataPath\"'");
            $result = ($res === 0);
        }
        Util::echoResult($msg, $result);
    }
}

$main = new Entrypoint();
$main->start();

